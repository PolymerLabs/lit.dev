One way your component can react to property changes is to compute values based on the new and existing property values. 

The `willUpdate()` callback is the ideal place to do these calculations in Lit. It's called near the beginning up the update cycle, before the component renders, so any properties you calculate during `willUpdate()` are available in your `render()` method.

The `willUpdate()` callback receives a map of changed properties as an argument, where the keys are property names and the values are the old values for each changed property. In this case, we'll compute a hash value based on the `name` property.

First, import the `computeSHA()` function:

```js
import {computeSHA} from './compute-sha.js';
```

Then add the `willUpdate()` callback:

{% switchable-sample %}

```ts
  protected willUpdate(changedProperties: PropertyValues<this>): void {
    // Only need to check changed properties for an expensive computation.
    if (changedProperties.has('name')) {
      computeSHA(this.name).then((sha) => this.sha = sha);
    }
  }
```

```js
  willUpdate(changedProperties) {
    // Only need to check changed properties for an expensive computation.
    if (changedProperties.has('name')) {
      computeSHA(this.name).then((sha) => this.sha = sha);
    }
  }
```

{% endswitchable-sample %}

Updating a reactive property during an update cycle callback like `willUpdate()` or `render()` does not trigger a new update cycle. However, if you initiate an asynchronous action from a lifecycle callback, it can trigger a new update. For example, the `computeSHA()` function here returns a promise. Setting `this.sha` in the promise callback *does* trigger a new update.
