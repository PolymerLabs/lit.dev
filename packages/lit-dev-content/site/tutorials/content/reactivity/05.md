For some reactive properties, you may want to customize _change detection_. By default, Lit uses a strict equality comparison to determine whether the new value is different from the old value (`newValue !== oldValue`).

In some cases, though, there's a better comparison. For example, an object like a JavaScript `Date`. Two different `Date` objects can represent the exact same time and date. Or you may only be interested in a few of the values from the object. In this case, it may be more efficient to write a custom `hasChanged` function for the property.

The component on the right lets you select a date. Whenever the component updates, the selected date flashes to show that it's been updated. If you choose a date from the picker and click the **Select date** button repeatedly, you'll see it flash every time, because a new `Date` object is being assigned.

To fix this, define the `dateHasChanged()` function. Put it at the top of the file, after the import statements.

{% switchable-sample %}

```ts
function dateHasChanged(newDate: Date, oldDate: Date|undefined): boolean {
  const hasChanged = (oldDate == undefined) ||
    !(newDate.getFullYear() == oldDate.getFullYear() &&
    newDate.getMonth() == oldDate.getMonth() &&
    newDate.getDate() == oldDate.getDate());
  return hasChanged;
}
```

```js
function dateHasChanged(newDate, oldDate) {
  const hasChanged = (oldDate == undefined) ||
    !(newDate.getFullYear() == oldDate.getFullYear() &&
    newDate.getMonth() == oldDate.getMonth() &&
    newDate.getDate() == oldDate.getDate());
  return hasChanged;
```

{% endswitchable-sample %}

Next, add the function to the property declaration:

{% switchable-sample %}

```ts
@property({hasChanged: dateHasChanged})
```

```js
date: {hasChanged: dateHasChanged}
```

{% endswitchable-sample %}

