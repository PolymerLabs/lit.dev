Now let's make setting the `selected` property actually do something. We'll set
the `name` attribute of our `slot` to `selected` to only show the selected
child element. Then we'll set the selected element's `slot` to `selected`.
Since the selected item is not rendered by Lit, we need to do it imperatively
in the `updated` lifecycle callback. We can use the `changedProperties` map
to do work only if certain properties (here `selected`) have changed.
We keep track of the previously selected item so we can unset its slot.

{% switchable-sample %}

```ts
render() {
  return html`
    <div class="item">
      <slot name="selected"></slot>
    </div>
  `;
}

private previous?: number;
protected updated(changedProperties: PropertyValues) {
  if (changedProperties.has('selected') ||  this.previous === undefined) {
    this.updateSlots();
    this.previous = this.selected;
  }
}

private updateSlots() {
  this.children[this.previous!]?.removeAttribute('slot');
  this.children[this.selected]?.setAttribute('slot', 'selected');
}
```

```js
render() {
  return html`
    <div class="item">
      <slot name="selected"></slot>
    </div>
  `;
}

updated(changedProperties) {
  if (changedProperties.has('selected') ||  this.previous === undefined) {
    this.updateSlots();
    this.previous = this.selected;
  }
}

updateSlots() {
  this.children[this.previous]?.removeAttribute('slot');
  this.children[this.selected]?.setAttribute('slot', 'selected');
}
```

{% endswitchable-sample %}

<aside class="info">The <i>slot</i> element also has an
<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assign">assign</a></code> method to assign
an element to the slot without needing to match the element's <i>slot</i> attribute
to the slot's name. However, this isn't yet widely supported so the code here
sets the element's <i>slot</i>. </aside>
