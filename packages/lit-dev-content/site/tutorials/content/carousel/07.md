Now you're ready to position the elements.

Update the top of the `render` method to look like this:

```ts
render() {
  const shouldMove = this.hasUpdated &&
      this.selected !== this.previous;
  const shouldAdvance = shouldMove && this.isAdvancing;
  const delta = (shouldMove ? Number(shouldAdvance) || -1 : 0) * 100;
  this.left -= delta;
  const animateLeft = `${this.left}%`;
  const selectedLeft = `${-this.left}%`;
  const previousLeft = `${-this.left - delta}%`;
```

The code here uses ReactiveElement's `hasUpdated` property to avoid animating the
first render and animates only if the selection has changed
(`this.selected !== this.previous`).

The animation advances to the right based on the `isAdvancing` property setup
in the `selected` accessor.

The move `delta` is calculated and from that the tracking `left` property. It
stores a `%` value indicating where the slot "container" element should be
positioned. It's stored as state so the element re-renders correctly if it
updates and the `selected` property has not changed.

Finally, the positions are set based on the `left` property. The animating
container (`animateLeft`) is the position stored in `left`.
The selected item (`selectedLeft`) needs to display so it's just the inverse
of `left`. And for the previous item (`previousLeft`), it's placed to the left
or right of the selected item based on the move `delta`.

If that's all done correctly, the carousel's behavior should be the same
as the previous step when you click and shift-click the element.

If you'd like to verify the positioning of the previous item, open the
`styles` module and remove `overflow: hidden` in the `:host` selector.
