The element still works as before, but now we're ready to add animation. To do
so, we'll import the `animate` directive from the `@lit-labs/motion` package.

```ts
import {animate} from '@lit-labs/motion';
```

<aside class="info">
  Normally, you'd also need to add <code>@lit-labs/motion</code> to your
  <code>package.json</code> but to speed things up, that's already been done.
</aside>

Now we'll add the animation to the `render` method. We need some code to
control where to place the `mover`. We use ReactiveElement's `hasUpdated`
property to avoid animating the first render. Then we move only if selection
has changed (`this.selected !== this.previous`). We go to the right based on
the `advancing` property we setup in the `selected` accessor.

```ts
render() {
  const shouldMove = this.hasUpdated && this.selected !== this.previous;
  const shouldAdvance = shouldMove && this.advancing;
  const x = shouldMove ? shouldAdvance ? 2 : 0 : 1;
  const left = `-${x}00%`;
  // ...
```

The `animate` directive will take care of animating the mover's position. It's
great for "tweening" between different rendered layouts. In this case, however,
we want to move right or left and then reset the layout back to the center
without animating. To do that, we use the directive's `onComplete` callback
to trigger an additional update, ensuring the animation is `disabled`.

<aside class="warning">
  Requesting <i>additional</i> updates when an action triggered by
  update completes is a powerful technique, but it must be done with care to
  avoid excessive or <i>infinite</i> execution.

  We <i>carefully</i> avoided an infinite loop here (<code>update -> animation ->
  update</code>) by ensuring that when the animation completes, the update we
  request will <i>not</i> trigger another animation
  (<code>update -> animation -> update -> NO animation</code>).
</aside>

```ts
return html`
  <div class="mover"
    ${animate(() => ({
        disabled: this.selected === this.previous,
        onComplete: () => this.requestUpdate()
    }))}
```

<aside class="info">
One more quick note: even though we're setting the <code>mover</code>'s
<code>left</code> property, the <code>animate</code> directive is actually
animating the css <code>transform</code> property. This is much more efficient
since it does not require the browser to perform layout or style
recalculation. Check out this
<a href="https://aerotwist.com/blog/flip-your-animations/">article on FLIP</a>
to learn more about the technique used by the <code>animate</code> directive.
</aside>
