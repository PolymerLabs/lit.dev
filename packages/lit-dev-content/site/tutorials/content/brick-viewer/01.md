### Define a property

It would be great if a user of the `<brick-viewer>` could specify which brick model to display using an attribute, like this:

```html
<brick-viewer src="path/to/model.ldraw"></brick-viewer>
```

Since you are building an HTML element, you can take advantage of the declarative API and define a source attribute, just like an `<img>` or `<video>` tag. With lit-element, it's as easy as decorating a class property with `@property`. The `type` option lets you specify how lit-element parses the property for use as an HTML attribute.

Define the `src` property and attribute:

{% switchable-sample %}

```ts
export class BrickViewer extends LitElement {
  @property({type: String})
  src: string|null = null;
}
```

```js
class BrickViewer extends LitElement {
  static properties = {
    src: {type: String},
  };
}
customElements.define('brick-viewer', BrickViewer);
```

{% endswitchable-sample %}

### Displaying values

You can display the value of the `src` attribute by using it in the render method's template literal. Interpolate values into template literals using `${value}` syntax.

```js
export class BrickViewer extends LitElement {
  render() {
    return html`<div>Brick model: ${this.src}</div>`;
  }
}
```

Now, you can see the value of the src attribute in the `<brick-viewer>` element in the window. Try this: open your browser's developer tools and manually change the src attribute. Go ahead, try it...

...Did you notice that the text in the element updates automatically? lit observes the class properties decorated with `@property` and re-render the view for you! lit does the heavy lifting so you don't have to.

<aside class="info">

Wondering about re-rendering efficiency? [lit](https://lit.dev/docs/components/rendering/) will only update the parts of your templates that change, without DOM diffing.

</aside>
