The methods used in the previous steps are great when working with a single
iterable as a source of data but sometimes the situation might call for a more
imperative approach.

In this example, we have a string array property `members`, a string array
property `pets`, a boolean state `includePets` controlled by a button, and
another boolean state `includeSeparator` also controlled by a button. The
desired result is to render a list item for each member but also include pets
if `includePets` is `true`, and some separating text between them if
`includeSeparator` is `true`.

Populate the `templates` array conditionally based on the boolean states
like shown below.

{% switchable-sample %}

```ts
// my-element.ts
const templates = [];
for (const member of this.members) {
  templates.push(html`<li>${member}</li>`);
}
if (this.includeSeparator) {
  templates.push('üê∂ Pets üê±');
}
if (this.includePets) {
  for (const pet of this.pets) {
    templates.push(html`<li>${pet}</li>`);
  }
}
```

```js
// my-element.js
const templates = [];
for (const member of this.members) {
  templates.push(html`<li>${member}</li>`);
}
if (this.includeSeparator) {
  templates.push('üê∂ Pets üê±');
}
if (this.includePets) {
  for (const pet of this.pets) {
    templates.push(html`<li>${pet}</li>`);
  }
}
```

{% endswitchable-sample %}

It can then be placed inside the template returned from the render method.

{% switchable-sample %}

```ts
// my-element.ts
return html`
  ...
  <ul>
    ${templates}
  </ul>
`
```

```js
// my-element.js
return html`
  ...
  <ul>
    ${templates}
  </ul>
`
```

{% endswitchable-sample %}

Click the buttons to see if the conditional rendering is working properly.

<aside class="positive">

Remember that any valid JavaScript expressions can be placed within the tagged
template literal that result in valid renderable values described
[here](/docs/templates/expressions/). This could be a variable
containing an array of `TemplateResult` and strings as done here, an array
method call returning an array like seen in the previous step, or even an
invocation of a custom written function that returns something renderable.

<br>

Try refactoring the code here to abstract out the logic from the `render` method
into its own private method that returns the templates.

</aside>