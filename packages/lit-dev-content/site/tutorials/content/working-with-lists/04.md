There are several ways of adding event listeners on each item getting rendered
from a list, but care must be taken to ensure the correct information is made
available to the event handler. This step shows one way of achieving this.

This example currently has an array of strings in the `items` property that
is being rendered as list items. There's a state called `lastIndex` that should
be updated to the index of the last list item that the mouse was over.

To achieve this, first create a method that will be called when the `mouseenter`
happens that will take a new index as its parameter.
```ts
// my-element.ts
class MyElement extends LitElement {
  ...
  private _updateLastIndex(newIndex: number) {
    this.lastIndex = newIndex;
  }
}
```

```js
// my-element.js
class MyElement extends LitElement {
  ...
  _updateLastIndex(newIndex) {
    this.lastIndex = newIndex;
  }
}
```

Then register the handler on the list item as the array is being mapped.

```ts
// my-element.ts
${this.items.map(
  (item, index) => html`
    <li @mouseenter=${() => this._updateLastIndex(index)}>${item}</li>
  `
)}
```

```js
// my-element.js
${this.items.map(
  (item, index) => html`
    <li @mouseenter=${() => this._updateLastIndex(index)}>${item}</li>
  `
)}
```

Now mousing over the different city names should update the one displayed up
top. Note that an inline arrow function is used here to create closures such
that each list item gets a function that calls `_updateLastIndex` with its own
index.

<aside class="info">

While closures will be fine for most cases, there are other ways to achieve
this behavior. For instance, a property or attribute can be left on the `<li>`
element which then can be accessed by the event handler via `event.target`.

<br>

When listening to an event that bubbles, using event delegation can be a
convenient way of handling it without attaching event listeners on every item.
Read more about it
[here](/docs/components/events/#listening-to-events-fired-from-repeated-templates).

</aside>