Sometimes you may want to render a list from somthing other than an array,
such as a `Set`. Note the data in this example has been changed from an
array to a `Set`.

An array of templates can be manually built from the `Set` by using a
`for ... of` loop, for example.

{% switchable-sample %}

```ts
// my-element.ts
const templates = [];
for (const item of this.items) {
  templates.push(html`<li>${item}</li>`);
}
```

```js
// my-element.js
const templates = [];
for (const item of this.items) {
  templates.push(html`<li>${item}</li>`);
}
```

{% endswitchable-sample %}

It can then be placed inside the template returned from the render method.

{% switchable-sample %}

```ts
// my-element.ts
return html`
  <ul>
    ${templates}
  </ul>
`
```

```js
// my-element.js
return html`
  <ul>
    ${templates}
  </ul>
`
```

{% endswitchable-sample %}

This is especially useful in complex situations that calls for building up a
list of items, for instance, from multiple sources or conditions.

<aside class="info">
Remember that any valid JavaScript expressions can be placed within the tagged
template literal that result in valid values that Lit can accept elaborated
<a href="/docs/templates/expressions/">here</a>. This could be a variable
containing an array of <code>TemplateResult</code>s as seen here, a function
call returning the same as seen in the previous step, or even an invocation
of a custom written function that returns something renderable.
</aside>

However, when working with a single iterable, there is a more declarative way
of writing this shown in the next step.