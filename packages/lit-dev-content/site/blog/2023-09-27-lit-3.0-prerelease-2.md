---
tags: blogPosts
layout: blog-post.html
title: "Lit 3.0 Prerelease 2 and more!"
summary: "Today we are publishing the second prerelease of Lit 3.0."
date: 2023-09-27
author:
  - justin-fagnani
---

# Lit 3.0 Prerelease 2 and more!

Today we are publishing the second prerelease of Lit 3.0.

This prerelease includes:
- The core Lit 3.0 packages
- The first graduating class of Lit Labs: Task, Context, and React
- Our first preview of our new optimizing template compiler
- A Preact Signals integration library

There are many other packages in this prerelease. See the full list and how to try them our [here]().

## Lit 3.0 Prerelease 2

As we [announced with the first prerelease](./2023-05-15-lit-3.0-prerelease/), Lit 3.0 is a breaking change that most notably removes support for IE11. Lit 3.0 is intended to have no new features, since new features can be added in non-breaking minor versions.

### Breaking changes

- IE11 is no longer supported.
- Lit's npm modules are now published as ES2021.
- APIs deprecated with the Lit 2.0 release have been removed.
- SSR hydration support modules are moved to the `@lit-labs/ssr-client` package.
- Decorator behavior has been unified between TypeScript experimental decorators and standard decorators.
- Support was removed for Babel decorators version "2018-09"

These breaking changes should have minimal impact for most users – based on testing against Google's codebase, they impact about one in a thousand elements – and allow our project to move forward more efficiently.

### New: standard decorators support

The one new feature that we _did_ add to Lit 3.0 is support for the TC39 standard decorators specification to our _existing_ decorators.

The new decorator spec has reached Stage 3 in TC39, meaning that browsers and compilers are now implementing them. This is a huge step for Lit! The arrival of standard decorators allows us to begin the process of moving to a decorator implementation that won't require a compiler to use.

It's very important to us to make the upgrade path from experimental decorators as smooth as possible. To accomplish this we made our existing decorators support the standard spec and made them work with the new `accessor` keyword in experimental decorator mode.

This way you can use Lit decorators with auto-accessors (using the `accessor` keyword) so that the same call site works with both settings:

```ts
class MyElement extends LitElement {
  @property()
  accessor myProperty = 'hello';
}
```

Once all decorator call sites in your project use the `accessor` keyword, you can build with `experimentalDecorators` set to `true` or `false`.

But in order to make these hybrid decorators have consistent behavior in both modes we had to make a few minor breaking changes to our experimental decorators.

These breaking changes were required because it's not possible to differentiate between auto-accessors and hand-written accessors. We now call `requestUpdate()` automatically for `@property` and `@state` decorated accessors where previously that was the setter's responsibility. We also will read the value of an accessor on first render and use that as the initial value for `changedProperties` and attribute reflection.

Standard decorator mode requires [TypeScript 5.2](https://devblogs.microsoft.com/typescript/announcing-typescript-5-2/#decorator-metadata) or [Babel 7.23](https://babeljs.io/blog/2023/09/25/7.23.0) with the `@babel/plugin-proposal-decorators` plugin using decorator version `"2023-05"`.

## New Lit template compiler!

The releases today also include the first preview of our new template compiler. This is a TypeScript compiler transform that compiles lit-html templates into a prepared representation (by inserting binding markers and creating template parts) so that the template prep steps are skipped at runtime. This can improve first render performance, sometimes dramatically. All template behavior remains exactly the same.

We plan on offering the compiler in a number of tool plugin formats, but for now we just have a TypeScript transform. One of the easiest ways to use it is via Rollup's TypeScript plugin, which allows you to add transforms:

`rollup.config.js`:
```js
import typescript from '@rollup/plugin-typescript';
import {compileLitTemplates} from '@lit-labs/compiler';

export default {
  // ...
  plugins: [
    typescript({
      transformers: {
        before: [compileLitTemplates()],
      },
    }),
    // other rollup plugins
  ],
};
```

## Preact Signals integration

Signals are all the rage right now. For Lit developers Signals promise to offer a convenient and relatively simple option for shared observable state.

One issue that signals present for web components is that signals lack interoperability between implementations. This goes against the interoperability goals of web components, so for now, rather than build our own signals package or pick just one that we endorse, we plan on offering integration packages to be able to use signal libraries with Lit.

These integrations will be relatively simple because we have two straight-forward ways of using signals:
1. Treat a component's update lifecycle as an effect, so that it's run when any signals it accesses (like in templates) changes. This integrates signals with Lit's batching async lifecycle for good performance when many signals change.
2. Use a directive to wire a signal directly to a location in DOM.

The new `@lit-labs/preact-signals` package provides this integration for [Preact Signals](https://preactjs.com/guide/v10/signals/) which is published as a standalone library.

Our new package provides three ways to use signals:
1. A `SignalWatcher` mixin, which makes a component automatically watch all signals used during updates.
2. A `watch()` directive, which watches one signal and updates a binding with it.
2. A special `html` template tag that auto-applies the `watch()` directive to all bindings that use signals.

Here's an example of using the `SignalWatcher` mixin:

```ts
import {LitElement, html} from 'lit';
import {customElement, property} from 'lit';
import {SignalWatcher, signal} from '@lit-labs/preact-signals';

const count = signal(0);

@customElement('signal-example')
export class SignalExample extends SignalWatcher(LitElement) {
  static styles = css`
    :host {
      display: block;
    }
  `;

  render() {
    return html`
      <p>The count is ${count.value}</p>
      <button @click=${this._onClick}>Increment<button></button></button>
    `;
  }

  private _onClick() {
    count.value = count.value + 1;
  }
}
```

## Lit Labs graduation

We are also graduating our first set of Lit Labs packages: Context, Task, and React.

These packages have a new home in the `@lit` npm scope, but are otherwise exactly the same as the current labs version.

## Trying out the prerelease

The packages in the prerelease are:

- `lit@3.0.0-pre.1`
- `lit-element@4.0.0-pre.1`
- `lit-html@3.0.0-pre.1`
- `@lit/reactive-element@2.0.0-pre.1`
- `@lit/context@1.0.0-pre.0`
- `@lit/react@1.0.0-pre.0`
- `@lit/task@1.0.0-pre.0`
- `@lit-labs/compiler@1.0.0-pre.0`
- `@lit-labs/preact-signals@1.0.0-pre.0`

<details>
  <summary>plus our other packages that depend on those:</summary>

- `@lit/localize-tools@0.7.0-pre.1`
- `@lit/localize@0.12.0-pre.1`
- `@lit/ts-transformers@2.0.0-pre.1`
- `@lit-labs/analyzer@0.10.0-pre.0`
- `@lit-labs/cli-localize@0.2.0-pre.1`
- `@lit-labs/cli@0.6.1-pre.0`
- `@lit-labs/context@0.5.0-pre.0`
- `@lit-labs/eleventy-plugin-lit@1.0.2-pre.1`
- `@lit-labs/gen-manifest@0.3.0-pre.0`
- `@lit-labs/gen-utils@0.3.0-pre.0`
- `@lit-labs/gen-wrapper-react@0.3.0-pre.0`
- `@lit-labs/gen-wrapper-vue@0.3.0-pre.0`
- `@lit-labs/motion@1.0.5-pre.0`
- `@lit-labs/nextjs@0.1.2-pre.1`
- `@lit-labs/observers@2.0.1-pre.1`
- `@lit-labs/react@2.1.1-pre.0`
- `@lit-labs/router@0.1.2-pre.1`
- `@lit-labs/scoped-registry-mixin@1.0.2-pre.1`
- `@lit-labs/ssr-client@1.1.4-pre.1`
- `@lit-labs/ssr-dom-shim@1.1.2-pre.1`
- `@lit-labs/ssr-react@0.2.1-pre.0`
- `@lit-labs/ssr@3.1.8-pre.0`
- `@lit-labs/task@3.1.0-pre.0`
- `@lit-labs/testing@0.2.2-pre.1`
- `@lit-labs/virtualizer@2.0.8-pre.0`
- `@lit-labs/vue-utils@0.1.1-pre.1`

</details>
